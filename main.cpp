
/*
    Данная задача является бонусной высокого уровня, она гарантирует вам +1.5 балла при чистом решении к 10-бальной оценке в конце
    семестра в случае, если ваша оценка на тот момент будет >= уд(3).

    Тем не менее дедлайн для отправки решений - 16 марта, 23:00.

    Решать данную задачу на интерпретируемых языках не имеет смысла, так как они дадут просадку производительности "из коробки"
    Желательно - С++, но готов рассматривать Go, Rust, C.

    Неполные решения (например реализация лишь одного из алгоритмов, будут так же оценены, возможно в +0.5 -- +1 балл к итоговой)
*/

/*
    Хотя в нашем курсе класс задач и языков NP рассматривается как нечто трудное,
    что не стоит даже пытаться решать за полином, на практике подобные задачи решать все же приходится.
    Обычно используются различные эвристики, которые все так же плохи в худшем случае, как и полный перебор,
    но способные на большей части возможных входов давать быстрый ответ.

    В этот раз мы предлагаем вам решить задачу поиска клик в неориентированных графах без петель и кратных ребер,
    используя 2 различных алгоритма, а потом сравнить их результат.

    1. Детерминированный алгоритм, базирующийся на принципе meet-in-the-middle. На семинаре вам будет рассказано
        применение этой идеи для решения NP-полной задачи, несколько похожей на SUBSET-SUM (видимо, пока не будет, поэтому конспект в конце файла),
        а так же задачи дискретного логарифмирования: https://en.wikipedia.org/wiki/Baby-step_giant-step, он же -- Алгоритм Шенкса

        Вам стоит самостоятельно реализовать проверку работы реализации и замер времени работы. От вас ожидается, что граф на
        48 вершинах будет обрабатываться примерно секунду. (Мне с помощью алгоритмических и технических трюков, основанных
        на особенностях работы процессоров intel удалось обрабатывать 54 вершины за 0.8 секунд, сложность имеет вид ~2^(N/2) * N)
        Этот алгоритм показывает примерно одинаковое время работы на любых графах и не имеет сильно выраженных лучших и худших случаев.

    2. Эвристический алгоритм "Ветвей и границ", он же "Branches and bounds". Вот полезная статья на эту тему: https://bit.ly/2VwVGta.
        Эвристические алгоритмы позволяют осуществлять полный перебор с выбором некоторых приоритетных направлений, которые
        скорее всего и будут содержать решение. Не без ложки дегтя: для большинства эвристик существуют контрпримеры, для
        которых они показывают просто ужасные результаты, хоть и решают правильно.

        В практических задачах обычно сначала используется этот подход. В случае, если он не дает решения за некоторое время
        происходит смена алгоритма на другой.
*/

/*
    Граф стоит хранить в отдельном классе для обеспечения архитектуры и читаемости кода
*/
/*
    От приведенного выше класса вам стоит унаследовать 2 потомков, первый будет предоставлять реализацию MITM
    алгоритма, а второй - эвристики.

    Определить способ хранения можно как в обоих потомках (возможно различным), но реализацию AddEdge и хранения графа
    я бы предложит реализовывать в Graph.

    На любые вопросы по С++ готов ответить в личке или после семинаров.
*/
/*
    Задача, демонстрирующая еще один способ применения идеи MITM

    Условие:
        На вход программе подаются N целых чисел, нужно найти два непересекающихся непустых подмножества этих чисел таких,
        что суммы чисел каждого подмножества будут равны.

    Решение в лоб:
        Рассмотрим все N-значные числа в троичной системе исчисления, в каждом из них 0 на i позиции будет означать, что i число не взять,
        1 - что оно принадлежит первому подмножеству, 2 - второму. Для каждого числа проверим условие, что соответствующие подмножества не пусты и
        их суммы совпадают. Оценка сложности снизу -- \Omega(3^N), как перебор количества разбиений. На самом деле все еще немного хуже,
        так как для каждого разбиения нужно считать сумму.

    Решение по MITM:
        1. Разобьем числа на две группы по N/2. (если N нечетно, то группы будут отличаться размерном на 1)
        2. Для каждой группы построим аналогично предыдущему решению 3^(N/2) разбиений и вычислим их суммы, причем
            в этот раз включим в перебор и такие разбиения, где одно из множеств (а может и оба) будет пустым.
            Сохраним не обе суммы, а лишь только разность между ними вместе с описанием разбиений в массивы A и B.
            (А хранит пары <разбиение, разность сумм подмножеств> для первой половины всех чисел, B - для второй,
            итого их размеры в районе 3^(N/2))

        3. Отсортируем A и B по возрастанию и за линейное по их сумме длин время будем перебирать все пары a[i] \in A, b[i] \in B, таких,
            что a[i] == b[i].

        4. Чуть-чуть подумаем над процессом из п. 3 и выведем ответ.

        Идея: Если есть два равных числа в массивах, то a[l] = \sum_i A[s_i] - \sum_j A[k_j], то b[q] = \sum_r B[p_r] - \sum_t B[u_t],
            Тогда \sum_i A[s_i] + \sum_t B[u_t] = \sum_r B[p_r] + \sum_j A[k_j] - мы нашли два равных по сумме непересекающихся подмножества.
            Проверка на непустоту осуществляется отдельно.

*/

#include "GraphMITM.h"
#include "GraphBRAB.h"
// #include "BeautifulPrint.h"
#include "CliqueInfo.h" 
#include <fstream>
#include <cstdint>
#include <string>
#include <sstream>
#include <chrono>
// using namespace Logger;

std::vector< std::vector<int> > get_graph_from_file(std::string dir){
    // Открывает файл graph.txt, преобразует данные из него в матрицу инцедентности
    std::ifstream in;
    in.open(dir);
    if (!in.is_open()){
        std::cout << "invalid file";
        exit(0);
    }
    std::string line;
    std::string tmp_str;
    std::vector <int> tmp_vect;
    std::vector < std::vector <int> > res;

    while(std::getline(in, line)){
        std::istringstream ist(line);
        while (ist >> tmp_str){
            tmp_vect.push_back(std::stoi(tmp_str));
        }
        res.push_back(tmp_vect);
        tmp_vect.clear();
    }
    in.close();
    return res;
}


// /Users/MaximZubkov/Desktop/Math/AMC/bonus/bonus/graph.txt это я для себя

int main(int argc, char * argv[]) {

    int k = 5;
    std::vector< std::vector<int> > matrix = get_graph_from_file(argv[1]);
    clock_t start_time =  std::clock();
    GraphBRAB graphBRAB(matrix.size(), matrix);
    clock_t end_time =  std::clock();
    std::cout << "timeBRAB: " << (end_time - start_time)/ (double) CLOCKS_PER_SEC << "\n";
    start_time =  std::clock();
    GraphMITM graphMITM(matrix.size(), matrix);
    end_time =  std::clock();
    std::cout << "timeMITM: " << (end_time - start_time)/ (double) CLOCKS_PER_SEC << "\n";
    std::cout << "time: " << (end_time - start_time) / (double) CLOCKS_PER_SEC << "\n";
    std::cout << "Has clique size " << k << ": "<< graphMITM.HasClique(k) << "\n";
    std::cout << "Max clique size: " << graphMITM.GetMaxCliqueSize() << "\n";
    std::vector<int> v = graphMITM.GetMaxClique();
    std::cout << "Vertexes in max clique: ";
    for (int i = 0; i < v.size(); i++){
        std::cout << v[i] << " ";
    }
    std::cout << "\n";
    return 0;
}
